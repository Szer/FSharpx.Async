<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>F# Async: AsyncSeq
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="description" content="Async extensions for F#"/>
    <meta name="author" content="Thomas Petricek, David Thomas, Steffen Forkmann"/>

    <script src="https://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="https://code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet"/>

    <link type="text/css" rel="stylesheet" href="/FSharpx.Async/content/style.css" />
    <script type="text/javascript" src="/FSharpx.Async/content/tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="https://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li><a href="http://fsharp.org">fsharp.org</a></li>
          <li><a href="http://github.com/fsprojects/FSharpx.Async">github page</a></li>
        </ul>
        <h3 class="muted"><a href="/FSharpx.Async/index.html">FSharpx.Async</a></h3>
      </div>
      <hr />
      <div class="row">
        <div class="span9" id="main">
          
<h1><a name="F-Async-AsyncSeq" class="anchor" href="#F-Async-AsyncSeq">F# Async: AsyncSeq</a></h1>

<p>An AsyncSeq is a sequence in which individual elements are retrieved using an <code>Async</code> computation.
It is similar to <code>seq&lt;'a&gt;</code> in that subsequent elements are pulled lazily. Structurally it is
similar to <code>list&lt;'a&gt;</code> with the difference being that each head and tail node or empty node is wrapped
in <code>Async</code>. <code>AsyncSeq</code> also bears similarity to <code>IObservable&lt;'a&gt;</code> with the former being pull-based and the
latter push-based. Analogs for most operations defined for <code>Seq</code>, <code>List</code> and <code>IObservable</code> are also defined for 
<code>AsyncSeq</code>. The power of <code>AsyncSeq</code> lies in that many of these operations also have analogs based on <code>Async</code> 
allowing one to compose complex asynchronous workflows.</p>

<p>The <code>AsyncSeq</code> type is located in the `FSharpx.Async.dll assembly which can be loaded in F# Interactive as follows:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="prep">#r</span> <span class="s">&quot;../../../bin/FSharpx.Async.dll&quot;</span>
<span class="k">open</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="i">FSharpx</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="i">Control</span>
</pre>
</td>
</tr>
</table>

<h3><a name="Generating-asynchronous-sequences" class="anchor" href="#Generating-asynchronous-sequences">Generating asynchronous sequences</a></h3>

<p>An <code>AsyncSeq&lt;'a&gt;</code> can be generated using computation expression syntax much like <code>seq&lt;'a&gt;</code>:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3)" class="i">asyncS</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="i">asyncSeq</span> {
  <span class="k">yield</span> <span class="n">1</span>
  <span class="k">yield</span> <span class="n">2</span>
}
</pre>
</td>
</tr>
</table>

<p>Another way to generate an asynchronous sequence is using the <code>Async.unfoldAsync</code> function. This
function takes another function which can generate individual elements based on a state and 
signal completion of the sequence.</p>

<p>For example, suppose that you're writing a program which consumes the Twitter API and stores tweets
which satisfy some criteria into a database. There are several asynchronous request-reply operations at play - 
one to retrieve a batch of tweets from the Twitter API, another to determine whether a tweet satisfies some
criteria and finally an operation to write the desired tweet to a database.</p>

<p>Given the type <code>Tweet</code> to represent an individual tweet, the operation to retrieve a batch of tweets can 
be modeled with a type <code>int -&gt; Async&lt;(Tweet[] * int) option&gt;</code> where the incoming <code>int</code> represents the 
offset into the tweet stream. The asynchronous result is an <code>Option</code> which when <code>None</code> indicates the
end of the stream, and otherwise contains the batch of retrieved tweets as well as the next offset.</p>

<p>The above function to retrieve a batch of tweets can be used to generate an asynchronous sequence 
of tweet batches as follows:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">type</span> <span onmouseout="hideTip(event, 'fs5', 5)" onmouseover="showTip(event, 'fs5', 5)" class="t">Tweet</span> <span class="o">=</span> {
  <span onmouseout="hideTip(event, 'fs6', 6)" onmouseover="showTip(event, 'fs6', 6)" class="i">user</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs7', 7)" onmouseover="showTip(event, 'fs7', 7)" class="t">string</span>
  <span onmouseout="hideTip(event, 'fs8', 8)" onmouseover="showTip(event, 'fs8', 8)" class="i">message</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs7', 9)" onmouseover="showTip(event, 'fs7', 9)" class="t">string</span>
}

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs9', 10)" onmouseover="showTip(event, 'fs9', 10)" class="f">getTweetBatch</span> (<span onmouseout="hideTip(event, 'fs10', 11)" onmouseover="showTip(event, 'fs10', 11)" class="i">offset</span><span class="o">:</span><span onmouseout="hideTip(event, 'fs11', 12)" onmouseover="showTip(event, 'fs11', 12)" class="t">int</span>) <span class="o">:</span> <span onmouseout="hideTip(event, 'fs12', 13)" onmouseover="showTip(event, 'fs12', 13)" class="t">Async</span><span class="o">&lt;</span>(<span onmouseout="hideTip(event, 'fs5', 14)" onmouseover="showTip(event, 'fs5', 14)" class="t">Tweet</span>[] <span class="o">*</span> <span onmouseout="hideTip(event, 'fs11', 15)" onmouseover="showTip(event, 'fs11', 15)" class="t">int</span>) <span onmouseout="hideTip(event, 'fs13', 16)" onmouseover="showTip(event, 'fs13', 16)" class="t">option</span><span class="o">&gt;</span> <span class="o">=</span> 
  <span onmouseout="hideTip(event, 'fs14', 17)" onmouseover="showTip(event, 'fs14', 17)" class="f">failwith</span> <span class="s">&quot;TODO: call Twitter API&quot;</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs15', 18)" onmouseover="showTip(event, 'fs15', 18)" class="i">tweetBatches</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs16', 19)" onmouseover="showTip(event, 'fs16', 19)" class="t">AsyncSeq</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs5', 20)" onmouseover="showTip(event, 'fs5', 20)" class="t">Tweet</span>[]<span class="o">&gt;</span> <span class="o">=</span> 
  <span onmouseout="hideTip(event, 'fs16', 21)" onmouseover="showTip(event, 'fs16', 21)" class="t">AsyncSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs17', 22)" onmouseover="showTip(event, 'fs17', 22)" class="f">unfoldAsync</span> <span onmouseout="hideTip(event, 'fs9', 23)" onmouseover="showTip(event, 'fs9', 23)" class="f">getTweetBatch</span> <span class="n">0</span>
</pre>
</td>
</tr>
</table>

<p>The asynchronous sequence <code>tweetBatches</code> will when iterated consume the entire tweet stream.</p>

<p>Next, suppose that the tweet filtering function makes a call to a web service which determines
whether a particular tweet should be stored in the database. This function can be modeled with
type <code>Tweet -&gt; Async&lt;bool&gt;</code>. We can flatten the <code>tweetBatches</code> sequence and then filter it as follows:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs18', 24)" onmouseover="showTip(event, 'fs18', 24)" class="f">filterTweet</span> (<span onmouseout="hideTip(event, 'fs19', 25)" onmouseover="showTip(event, 'fs19', 25)" class="i">t</span><span class="o">:</span><span onmouseout="hideTip(event, 'fs5', 26)" onmouseover="showTip(event, 'fs5', 26)" class="t">Tweet</span>) <span class="o">:</span> <span onmouseout="hideTip(event, 'fs12', 27)" onmouseover="showTip(event, 'fs12', 27)" class="t">Async</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs20', 28)" onmouseover="showTip(event, 'fs20', 28)" class="t">bool</span><span class="o">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs14', 29)" onmouseover="showTip(event, 'fs14', 29)" class="f">failwith</span> <span class="s">&quot;TODO: call web service&quot;</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 30)" onmouseover="showTip(event, 'fs21', 30)" class="i">filteredTweets</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs16', 31)" onmouseover="showTip(event, 'fs16', 31)" class="t">AsyncSeq</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs5', 32)" onmouseover="showTip(event, 'fs5', 32)" class="t">Tweet</span><span class="o">&gt;</span> <span class="o">=</span> 
  <span onmouseout="hideTip(event, 'fs15', 33)" onmouseover="showTip(event, 'fs15', 33)" class="i">tweetBatches</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs16', 34)" onmouseover="showTip(event, 'fs16', 34)" class="t">AsyncSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs22', 35)" onmouseover="showTip(event, 'fs22', 35)" class="f">concatSeq</span> <span class="c">// flatten</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs16', 36)" onmouseover="showTip(event, 'fs16', 36)" class="t">AsyncSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs23', 37)" onmouseover="showTip(event, 'fs23', 37)" class="f">filterAsync</span> <span onmouseout="hideTip(event, 'fs18', 38)" onmouseover="showTip(event, 'fs18', 38)" class="f">filterTweet</span> <span class="c">// filter</span>
</pre>
</td>
</tr>
</table>

<p>When the resulting sequence <code>filteredTweets</code> is consumed, it will lazily consume the underlying
sequence <code>tweetBatches</code>, select individual tweets and filter them using the function <code>filterTweets</code>.</p>

<p>Finally, the function which stores a tweet in the database can be modeled by type <code>Tweet -&gt; Async&lt;unit&gt;</code>.
We can store all filtered tweets as follows:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs24', 39)" onmouseover="showTip(event, 'fs24', 39)" class="f">storeTweet</span> (<span onmouseout="hideTip(event, 'fs19', 40)" onmouseover="showTip(event, 'fs19', 40)" class="i">t</span><span class="o">:</span><span onmouseout="hideTip(event, 'fs5', 41)" onmouseover="showTip(event, 'fs5', 41)" class="t">Tweet</span>) <span class="o">:</span> <span onmouseout="hideTip(event, 'fs12', 42)" onmouseover="showTip(event, 'fs12', 42)" class="t">Async</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs25', 43)" onmouseover="showTip(event, 'fs25', 43)" class="t">unit</span><span class="o">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs14', 44)" onmouseover="showTip(event, 'fs14', 44)" class="f">failwith</span> <span class="s">&quot;TODO: call database&quot;</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs26', 45)" onmouseover="showTip(event, 'fs26', 45)" class="i">storeFilteredTweets</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs12', 46)" onmouseover="showTip(event, 'fs12', 46)" class="t">Async</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs25', 47)" onmouseover="showTip(event, 'fs25', 47)" class="t">unit</span><span class="o">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs21', 48)" onmouseover="showTip(event, 'fs21', 48)" class="i">filteredTweets</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs16', 49)" onmouseover="showTip(event, 'fs16', 49)" class="t">AsyncSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs27', 50)" onmouseover="showTip(event, 'fs27', 50)" class="f">iterAsync</span> <span onmouseout="hideTip(event, 'fs24', 51)" onmouseover="showTip(event, 'fs24', 51)" class="f">storeTweet</span>
</pre>
</td>
</tr>
</table>

<p>Note that the value <code>storeFilteredTweets</code> is an asynchronous computation of type <code>Async&lt;unit&gt;</code>. At this point,
it is a <strong>representation</strong> of the workflow which consists of reading batches of tweets, filtering them and storing them
in the database. When executed, the workflow will consume the entire tweet stream. The entire workflow can be
succinctly declared and executed as follows:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span onmouseout="hideTip(event, 'fs16', 52)" onmouseover="showTip(event, 'fs16', 52)" class="t">AsyncSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs17', 53)" onmouseover="showTip(event, 'fs17', 53)" class="f">unfoldAsync</span> <span onmouseout="hideTip(event, 'fs9', 54)" onmouseover="showTip(event, 'fs9', 54)" class="f">getTweetBatch</span> <span class="n">0</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs16', 55)" onmouseover="showTip(event, 'fs16', 55)" class="t">AsyncSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs22', 56)" onmouseover="showTip(event, 'fs22', 56)" class="f">concatSeq</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs16', 57)" onmouseover="showTip(event, 'fs16', 57)" class="t">AsyncSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs23', 58)" onmouseover="showTip(event, 'fs23', 58)" class="f">filterAsync</span> <span onmouseout="hideTip(event, 'fs18', 59)" onmouseover="showTip(event, 'fs18', 59)" class="f">filterTweet</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs16', 60)" onmouseover="showTip(event, 'fs16', 60)" class="t">AsyncSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs27', 61)" onmouseover="showTip(event, 'fs27', 61)" class="f">iterAsync</span> <span onmouseout="hideTip(event, 'fs24', 62)" onmouseover="showTip(event, 'fs24', 62)" class="f">storeTweet</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs12', 63)" onmouseover="showTip(event, 'fs12', 63)" class="t">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs28', 64)" onmouseover="showTip(event, 'fs28', 64)" class="f">RunSynchronously</span>
</pre>
</td>
</tr>
</table>

<p>The above snippet effectively orchestrates several asynchronous request-reply interactions into a cohesive unit
composed using familiar operations on sequences. Furthermore, it will be executed efficiently in a non-blocking manner.</p>

<h3><a name="Comparison-with-seq-a" class="anchor" href="#Comparison-with-seq-a">Comparison with seq<'a></a></h3>

<p>The central difference between <code>seq&lt;'a&gt;</code> and <code>AsyncSeq&lt;'a&gt;</code> two can be illustrated by introducing the notion of time. 
Suppose that generating subsequent elements of a sequence requires an IO-bound operation. Invoking long 
running IO-bound operations from within a <code>seq&lt;'a&gt;</code> will <strong>block</strong> the thread which calls <code>MoveNext</code> on the 
corresponding <code>IEnumerator</code>. An <code>AsyncSeq</code> can use facilities provided by the F# <code>Async</code> type to make more efficient 
use of system resources.</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs29', 65)" onmouseover="showTip(event, 'fs29', 65)" class="i">withTime</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs30', 66)" onmouseover="showTip(event, 'fs30', 66)" class="i">seq</span> {
  <span onmouseout="hideTip(event, 'fs31', 67)" onmouseover="showTip(event, 'fs31', 67)" class="i">System</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs32', 68)" onmouseover="showTip(event, 'fs32', 68)" class="i">Threading</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs33', 69)" onmouseover="showTip(event, 'fs33', 69)" class="t">Thread</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs34', 70)" onmouseover="showTip(event, 'fs34', 70)" class="f">Sleep</span>(<span class="n">1000</span>) <span class="c">// calling thread will block</span>
  <span class="k">yield</span> <span class="n">1</span>
  <span onmouseout="hideTip(event, 'fs31', 71)" onmouseover="showTip(event, 'fs31', 71)" class="i">System</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs32', 72)" onmouseover="showTip(event, 'fs32', 72)" class="i">Threading</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs33', 73)" onmouseover="showTip(event, 'fs33', 73)" class="t">Thread</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs34', 74)" onmouseover="showTip(event, 'fs34', 74)" class="f">Sleep</span>(<span class="n">1000</span>) <span class="c">// calling thread will block</span>
  <span class="k">yield</span> <span class="n">1</span>
}

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs35', 75)" onmouseover="showTip(event, 'fs35', 75)" class="i">withTime&#39;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs4', 76)" onmouseover="showTip(event, 'fs4', 76)" class="i">asyncSeq</span> {
  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs12', 77)" onmouseover="showTip(event, 'fs12', 77)" class="t">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs36', 78)" onmouseover="showTip(event, 'fs36', 78)" class="f">Sleep</span> <span class="n">1000</span> <span class="c">// non-blocking sleep</span>
  <span class="k">yield</span> <span class="n">1</span>
  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs12', 79)" onmouseover="showTip(event, 'fs12', 79)" class="t">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs36', 80)" onmouseover="showTip(event, 'fs36', 80)" class="f">Sleep</span> <span class="n">1000</span> <span class="c">// non-blocking sleep</span>
  <span class="k">yield</span> <span class="n">2</span>
}
</pre>
</td>
</tr>
</table>

<p>When the asynchronous sequence <code>withTime'</code> is iterated, the calls to <code>Async.Sleep</code> won't block threads. Instead,
the <strong>continuation</strong> of the sequence will be scheduled by a <code>ThreadPool</code> thread, while the calling thread
will be free to perform other work. Overall, a <code>seq&lt;'a&gt;</code> can be viewed as a special case of an <code>AsyncSeq&lt;'a&gt;</code>.</p>

<h3><a name="Comparison-with-IObservable-a" class="anchor" href="#Comparison-with-IObservable-a">Comparison with IObservable<'a></a></h3>

<p>Both <code>IObservable&lt;'a&gt;</code> and <code>AsyncSeq&lt;'a&gt;</code> represent collections of items and both provide similar operations
for transformation and composition. The central difference between the two is that the former is push-based 
and the latter is pull-based. Consumers of an <code>IObservable&lt;'a&gt;</code> <strong>subscribe</strong> to receive notifications about
new items or completion. By contrast, consumers of an <code>AsyncSeq&lt;'a&gt;</code> <strong>retrieve</strong> subsequent items on their own
terms. Some domains are more naturally modeled with one or the other, however it is less clear which is a more
suitable tool for a specific task. In many cases, a combination of the two provides the optimal solution and 
restricting yourself to one, while simplifying the programming model, can lead one to view all problems as a nail.</p>

<p>A more specific difference between the two is that <code>IObservable&lt;'a&gt;</code> subscribers have the basic type <code>'a -&gt; unit</code> 
and are therefore inherently synchronous and imperative. The observer can certainly make a blocking call, but this 
can defeat the purpose of the observable sequence all together. Alternatively, the observer can spawn an operation, but
this can break composition because one can no longer rely on the observer operation returning to determine that it has 
completed. With the observable model however, we can model blocking operations through composition on sequences rather
than observers.</p>

<p>To illustrate, lets try to implement the above Tweet retrieval, filtering and storage workflow using observable sequences.
Suppose we already have an observable sequence representing tweets <code>IObservable&lt;Tweet&gt;</code> and we simply wish 
to filter it and store the resulting tweets. The function <code>Observable.filter</code> allows one to filter observable
sequences based on a predicate, however in this case it doesn't quite cut it because the predicate passed to it must
be synchronous <code>'a -&gt; bool</code>:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">open</span> <span onmouseout="hideTip(event, 'fs31', 81)" onmouseover="showTip(event, 'fs31', 81)" class="i">System</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs37', 82)" onmouseover="showTip(event, 'fs37', 82)" class="i">tweetsObs</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs38', 83)" onmouseover="showTip(event, 'fs38', 83)" class="t">IObservable</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs5', 84)" onmouseover="showTip(event, 'fs5', 84)" class="t">Tweet</span><span class="o">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs14', 85)" onmouseover="showTip(event, 'fs14', 85)" class="f">failwith</span> <span class="s">&quot;TODO: create observable&quot;</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs39', 86)" onmouseover="showTip(event, 'fs39', 86)" class="i">filteredTweetsObs</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs37', 87)" onmouseover="showTip(event, 'fs37', 87)" class="i">tweetsObs</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs40', 88)" onmouseover="showTip(event, 'fs40', 88)" class="t">Observable</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs41', 89)" onmouseover="showTip(event, 'fs41', 89)" class="f">filter</span> (<span onmouseout="hideTip(event, 'fs18', 90)" onmouseover="showTip(event, 'fs18', 90)" class="f">filterTweet</span> <span class="o">&gt;</span><span class="o">&gt;</span> <span onmouseout="hideTip(event, 'fs12', 91)" onmouseover="showTip(event, 'fs12', 91)" class="t">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs42', 92)" onmouseover="showTip(event, 'fs42', 92)" class="f">RunSynchronously</span>) <span class="c">// blocking IO-call!</span>
</pre>
</td>
</tr>
</table>

<p>To remedy the blocking IO-call we can better adapt the filtering function to the <code>IObservable&lt;'a&gt;</code> model. A value
of type <code>Async&lt;'a&gt;</code> can be modeled as an <code>IObservable&lt;'a&gt;</code> with one element. Suppose that we have 
<code>Tweet -&gt; IObservable&lt;bool&gt;</code>. We can define a few helper operators on observables to allow filtering using
an asynchronous predicate as follows:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
<span class="l">21: </span>
<span class="l">22: </span>
<span class="l">23: </span>
<span class="l">24: </span>
<span class="l">25: </span>
<span class="l">26: </span>
<span class="l">27: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">module</span> <span onmouseout="hideTip(event, 'fs40', 93)" onmouseover="showTip(event, 'fs40', 93)" class="t">Observable</span> <span class="o">=</span>
  
  <span class="c">/// a |&gt; Async.StartAsTask |&gt; (fun t -&gt; t.ToObservable())</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'fs43', 94)" onmouseover="showTip(event, 'fs43', 94)" class="f">ofAsync</span> (<span onmouseout="hideTip(event, 'fs44', 95)" onmouseover="showTip(event, 'fs44', 95)" class="i">a</span><span class="o">:</span><span onmouseout="hideTip(event, 'fs12', 96)" onmouseover="showTip(event, 'fs12', 96)" class="t">Async</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span>) <span class="o">:</span> <span onmouseout="hideTip(event, 'fs38', 97)" onmouseover="showTip(event, 'fs38', 97)" class="t">IObservable</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs14', 98)" onmouseover="showTip(event, 'fs14', 98)" class="f">failwith</span> <span class="s">&quot;TODO&quot;</span>

  <span class="c">/// Observable.SelectMany</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'fs45', 99)" onmouseover="showTip(event, 'fs45', 99)" class="f">bind</span> (<span onmouseout="hideTip(event, 'fs46', 100)" onmouseover="showTip(event, 'fs46', 100)" class="f">f</span><span class="o">:</span><span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs38', 101)" onmouseover="showTip(event, 'fs38', 101)" class="t">IObservable</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>) (<span onmouseout="hideTip(event, 'fs47', 102)" onmouseover="showTip(event, 'fs47', 102)" class="i">o</span><span class="o">:</span><span onmouseout="hideTip(event, 'fs38', 103)" onmouseover="showTip(event, 'fs38', 103)" class="t">IObservable</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span>) <span class="o">:</span> <span onmouseout="hideTip(event, 'fs38', 104)" onmouseover="showTip(event, 'fs38', 104)" class="t">IObservable</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs14', 105)" onmouseover="showTip(event, 'fs14', 105)" class="f">failwith</span> <span class="s">&quot;TODO&quot;</span>

  <span class="k">let</span> <span onmouseout="hideTip(event, 'fs48', 106)" onmouseover="showTip(event, 'fs48', 106)" class="f">filterObs</span> (<span onmouseout="hideTip(event, 'fs49', 107)" onmouseover="showTip(event, 'fs49', 107)" class="f">f</span><span class="o">:</span><span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs38', 108)" onmouseover="showTip(event, 'fs38', 108)" class="t">IObservable</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs50', 109)" onmouseover="showTip(event, 'fs50', 109)" class="t">bool</span><span class="o">&gt;</span>) <span class="o">:</span> <span onmouseout="hideTip(event, 'fs38', 110)" onmouseover="showTip(event, 'fs38', 110)" class="t">IObservable</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs38', 111)" onmouseover="showTip(event, 'fs38', 111)" class="t">IObservable</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs45', 112)" onmouseover="showTip(event, 'fs45', 112)" class="f">bind</span> <span class="o">&lt;|</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs51', 113)" onmouseover="showTip(event, 'fs51', 113)" class="i">a</span> <span class="k">-&gt;</span> 
      <span onmouseout="hideTip(event, 'fs49', 114)" onmouseover="showTip(event, 'fs49', 114)" class="f">f</span> <span onmouseout="hideTip(event, 'fs51', 115)" onmouseover="showTip(event, 'fs51', 115)" class="i">a</span>
      <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs40', 116)" onmouseover="showTip(event, 'fs40', 116)" class="t">Observable</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs52', 117)" onmouseover="showTip(event, 'fs52', 117)" class="f">choose</span> (<span class="k">function</span>
        | <span class="k">true</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs53', 118)" onmouseover="showTip(event, 'fs53', 118)" class="p">Some</span> <span onmouseout="hideTip(event, 'fs51', 119)" onmouseover="showTip(event, 'fs51', 119)" class="i">a</span>
        | <span class="k">false</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs54', 120)" onmouseover="showTip(event, 'fs54', 120)" class="p">None</span>
      )
  
  <span class="k">let</span> <span onmouseout="hideTip(event, 'fs55', 121)" onmouseover="showTip(event, 'fs55', 121)" class="f">filterAsync</span> (<span onmouseout="hideTip(event, 'fs56', 122)" onmouseover="showTip(event, 'fs56', 122)" class="f">f</span><span class="o">:</span><span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs12', 123)" onmouseover="showTip(event, 'fs12', 123)" class="t">Async</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs50', 124)" onmouseover="showTip(event, 'fs50', 124)" class="t">bool</span><span class="o">&gt;</span>) <span class="o">:</span> <span onmouseout="hideTip(event, 'fs38', 125)" onmouseover="showTip(event, 'fs38', 125)" class="t">IObservable</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs38', 126)" onmouseover="showTip(event, 'fs38', 126)" class="t">IObservable</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs48', 127)" onmouseover="showTip(event, 'fs48', 127)" class="f">filterObs</span> (<span onmouseout="hideTip(event, 'fs56', 128)" onmouseover="showTip(event, 'fs56', 128)" class="f">f</span> <span class="o">&gt;</span><span class="o">&gt;</span> <span onmouseout="hideTip(event, 'fs43', 129)" onmouseover="showTip(event, 'fs43', 129)" class="f">ofAsync</span>)

  <span class="k">let</span> <span onmouseout="hideTip(event, 'fs57', 130)" onmouseover="showTip(event, 'fs57', 130)" class="f">mapAsync</span> (<span onmouseout="hideTip(event, 'fs58', 131)" onmouseover="showTip(event, 'fs58', 131)" class="f">f</span><span class="o">:</span><span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs12', 132)" onmouseover="showTip(event, 'fs12', 132)" class="t">Async</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>) <span class="o">:</span> <span onmouseout="hideTip(event, 'fs38', 133)" onmouseover="showTip(event, 'fs38', 133)" class="t">IObservable</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs38', 134)" onmouseover="showTip(event, 'fs38', 134)" class="t">IObservable</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs45', 135)" onmouseover="showTip(event, 'fs45', 135)" class="f">bind</span> (<span onmouseout="hideTip(event, 'fs58', 136)" onmouseover="showTip(event, 'fs58', 136)" class="f">f</span> <span class="o">&gt;</span><span class="o">&gt;</span> <span onmouseout="hideTip(event, 'fs43', 137)" onmouseover="showTip(event, 'fs43', 137)" class="f">ofAsync</span>)

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs59', 138)" onmouseover="showTip(event, 'fs59', 138)" class="i">filteredTweetsObs&#39;</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs38', 139)" onmouseover="showTip(event, 'fs38', 139)" class="t">IObservable</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs5', 140)" onmouseover="showTip(event, 'fs5', 140)" class="t">Tweet</span><span class="o">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs39', 141)" onmouseover="showTip(event, 'fs39', 141)" class="i">filteredTweetsObs</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs60', 142)" onmouseover="showTip(event, 'fs60', 142)" class="t">Observable</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs55', 143)" onmouseover="showTip(event, 'fs55', 143)" class="f">filterAsync</span> <span onmouseout="hideTip(event, 'fs18', 144)" onmouseover="showTip(event, 'fs18', 144)" class="f">filterTweet</span>
</pre>
</td>
</tr>
</table>

<p>With a little effort, we were able to adapt <code>IObservable&lt;'a&gt;</code> to our needs. Next lets try implementing the storage of
filtered tweets. Again, we can adapt the function <code>storeTweet</code> defined above to the observable model and bind the
observable of filtered tweets to it:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs61', 145)" onmouseover="showTip(event, 'fs61', 145)" class="i">storedTweetsObs</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs38', 146)" onmouseover="showTip(event, 'fs38', 146)" class="t">IObservable</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs25', 147)" onmouseover="showTip(event, 'fs25', 147)" class="t">unit</span><span class="o">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs59', 148)" onmouseover="showTip(event, 'fs59', 148)" class="i">filteredTweetsObs&#39;</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs60', 149)" onmouseover="showTip(event, 'fs60', 149)" class="t">Observable</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs57', 150)" onmouseover="showTip(event, 'fs57', 150)" class="f">mapAsync</span> <span onmouseout="hideTip(event, 'fs24', 151)" onmouseover="showTip(event, 'fs24', 151)" class="f">storeTweet</span>
</pre>
</td>
</tr>
</table>

<p>The observable sequence <code>storedTweetsObs</code> will produces a value each time a filtered tweet is stored. The entire
workflow can be expressed as follows:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip">
<span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre>
</td>
<td class="snippet"><pre class="fssnip">
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs62', 152)" onmouseover="showTip(event, 'fs62', 152)" class="i">storedTeetsObs&#39;</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs38', 153)" onmouseover="showTip(event, 'fs38', 153)" class="t">IObservable</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs25', 154)" onmouseover="showTip(event, 'fs25', 154)" class="t">unit</span><span class="o">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs37', 155)" onmouseover="showTip(event, 'fs37', 155)" class="i">tweetsObs</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs60', 156)" onmouseover="showTip(event, 'fs60', 156)" class="t">Observable</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs55', 157)" onmouseover="showTip(event, 'fs55', 157)" class="f">filterAsync</span> <span onmouseout="hideTip(event, 'fs18', 158)" onmouseover="showTip(event, 'fs18', 158)" class="f">filterTweet</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs60', 159)" onmouseover="showTip(event, 'fs60', 159)" class="t">Observable</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs57', 160)" onmouseover="showTip(event, 'fs57', 160)" class="f">mapAsync</span> <span onmouseout="hideTip(event, 'fs24', 161)" onmouseover="showTip(event, 'fs24', 161)" class="f">storeTweet</span>
</pre>
</td>
</tr>
</table>

<p>Overall, both solutions are succinct and composable and deciding which one to use can ultimately be a matter of preference. 
Some things to consider are the push vs. pull semantics. On the one hand, tweets are pushed based - the consumer has no control 
over their generation. On the other hand, the program at hand will process the tweets on its own terms regardless of how quickly 
they are being generated. Moreover, the underlying Twitter API will likely utilize a request-reply protocol to retrieve batches of 
tweets from persistent storage. As such, the distinction between push vs. pull becomes less interesting. If the underlying source 
is truly push-based, then one can buffer its output and consume it using an asynchronous sequence. If the underlying source is pull-based, 
then one can turn it into an observable sequence by first pulling, then pushing. In a real-time reactive system, notifications must be pushed 
immediately without delay. This point however is moot since neither <code>IObservable&lt;'a&gt;</code> nor <code>Async&lt;'a&gt;</code> are well suited for 
real-time systems.</p>

<h3><a name="Performance-Considerations" class="anchor" href="#Performance-Considerations">Performance Considerations</a></h3>

<p>While an asynchronous computation obviates the need to block an OS thread for the duration of an operation, it isn't always the case
that this will improve the overall performance of an application. Note however that an async computation does not <strong>require</strong> a
non-blocking operation, it simply allows for it. Also of note is that unlike calling <code>IEnumerable.MoveNext()</code>, consuming
and item from an asynchronous sequence requires several allocations. Usually this is greatly outweighed by the
benefits, it can make a difference in some scenarios.</p>

<h2><a name="Related-Articles" class="anchor" href="#Related-Articles">Related Articles</a></h2>

<ul>
<li><a href="http://tomasp.net/blog/async-sequences.aspx/">Programming with F# asynchronous sequences</a></li>
</ul>

<div class="tip" id="fs1">namespace FSharpx</div>
<div class="tip" id="fs2">namespace FSharpx.Control</div>
<div class="tip" id="fs3">val asyncS : AsyncSeq&lt;int&gt;<br /><br />Full name: AsyncSeq.asyncS</div>
<div class="tip" id="fs4">val asyncSeq : AsyncSeq.AsyncSeqBuilder<br /><br />Full name: FSharpx.Control.AsyncSeqExtensions.asyncSeq</div>
<div class="tip" id="fs5">type Tweet =<br />&#160;&#160;{user: string;<br />&#160;&#160;&#160;message: string;}<br /><br />Full name: AsyncSeq.Tweet</div>
<div class="tip" id="fs6">Tweet.user: string</div>
<div class="tip" id="fs7">Multiple items<br />val string : value:&#39;T -&gt; string<br /><br />Full name: Microsoft.FSharp.Core.Operators.string<br /><br />--------------------<br />type string = System.String<br /><br />Full name: Microsoft.FSharp.Core.string</div>
<div class="tip" id="fs8">Tweet.message: string</div>
<div class="tip" id="fs9">val getTweetBatch : offset:int -&gt; Async&lt;(Tweet [] * int) option&gt;<br /><br />Full name: AsyncSeq.getTweetBatch</div>
<div class="tip" id="fs10">val offset : int</div>
<div class="tip" id="fs11">Multiple items<br />val int : value:&#39;T -&gt; int (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.int<br /><br />--------------------<br />type int = int32<br /><br />Full name: Microsoft.FSharp.Core.int<br /><br />--------------------<br />type int&lt;&#39;Measure&gt; = int<br /><br />Full name: Microsoft.FSharp.Core.int&lt;_&gt;</div>
<div class="tip" id="fs12">Multiple items<br />type Async<br />static member AsBeginEnd : computation:(&#39;Arg -&gt; Async&lt;&#39;T&gt;) -&gt; (&#39;Arg * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; &#39;T) * (IAsyncResult -&gt; unit)<br />static member AwaitEvent : event:IEvent&lt;&#39;Del,&#39;T&gt; * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt; (requires delegate and &#39;Del :&gt; Delegate)<br />static member AwaitIAsyncResult : iar:IAsyncResult * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />static member AwaitTask : task:Task&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;<br />static member AwaitWaitHandle : waitHandle:WaitHandle * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />static member CancelDefaultToken : unit -&gt; unit<br />static member Catch : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;Choice&lt;&#39;T,exn&gt;&gt;<br />static member FromBeginEnd : beginAction:(AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg:&#39;Arg1 * beginAction:(&#39;Arg1 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * beginAction:(&#39;Arg1 * &#39;Arg2 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * arg3:&#39;Arg3 * beginAction:(&#39;Arg1 * &#39;Arg2 * &#39;Arg3 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromContinuations : callback:((&#39;T -&gt; unit) * (exn -&gt; unit) * (OperationCanceledException -&gt; unit) -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member Ignore : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;unit&gt;<br />static member OnCancel : interruption:(unit -&gt; unit) -&gt; Async&lt;IDisposable&gt;<br />static member Parallel : computations:seq&lt;Async&lt;&#39;T&gt;&gt; -&gt; Async&lt;&#39;T []&gt;<br />static member RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:CancellationToken -&gt; &#39;T<br />static member Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;<br />static member Start : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br />static member StartAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:TaskCreationOptions * ?cancellationToken:CancellationToken -&gt; Task&lt;&#39;T&gt;<br />static member StartChild : computation:Async&lt;&#39;T&gt; * ?millisecondsTimeout:int -&gt; Async&lt;Async&lt;&#39;T&gt;&gt;<br />static member StartChildAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:TaskCreationOptions -&gt; Async&lt;Task&lt;&#39;T&gt;&gt;<br />static member StartImmediate : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br />static member StartWithContinuations : computation:Async&lt;&#39;T&gt; * continuation:(&#39;T -&gt; unit) * exceptionContinuation:(exn -&gt; unit) * cancellationContinuation:(OperationCanceledException -&gt; unit) * ?cancellationToken:CancellationToken -&gt; unit<br />static member SwitchToContext : syncContext:SynchronizationContext -&gt; Async&lt;unit&gt;<br />static member SwitchToNewThread : unit -&gt; Async&lt;unit&gt;<br />static member SwitchToThreadPool : unit -&gt; Async&lt;unit&gt;<br />static member TryCancelled : computation:Async&lt;&#39;T&gt; * compensation:(OperationCanceledException -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member CancellationToken : Async&lt;CancellationToken&gt;<br />static member DefaultCancellationToken : CancellationToken<br /><br />Full name: Microsoft.FSharp.Control.Async<br /><br />--------------------<br />type Async&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Control.Async&lt;_&gt;</div>
<div class="tip" id="fs13">type &#39;T option = Option&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Core.option&lt;_&gt;</div>
<div class="tip" id="fs14">val failwith : message:string -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Core.Operators.failwith</div>
<div class="tip" id="fs15">val tweetBatches : AsyncSeq&lt;Tweet []&gt;<br /><br />Full name: AsyncSeq.tweetBatches</div>
<div class="tip" id="fs16">Multiple items<br />module AsyncSeq<br /><br />from FSharpx.Control<br /><br />--------------------<br />type AsyncSeq&lt;&#39;T&gt; = Async&lt;AsyncSeqInner&lt;&#39;T&gt;&gt;<br /><br />Full name: FSharpx.Control.AsyncSeq&lt;_&gt;</div>
<div class="tip" id="fs17">val unfoldAsync : f:(&#39;State -&gt; Async&lt;(&#39;T * &#39;State) option&gt;) -&gt; s:&#39;State -&gt; AsyncSeq&lt;&#39;T&gt;<br /><br />Full name: FSharpx.Control.AsyncSeq.unfoldAsync</div>
<div class="tip" id="fs18">val filterTweet : t:Tweet -&gt; Async&lt;bool&gt;<br /><br />Full name: AsyncSeq.filterTweet</div>
<div class="tip" id="fs19">val t : Tweet</div>
<div class="tip" id="fs20">type bool = System.Boolean<br /><br />Full name: Microsoft.FSharp.Core.bool</div>
<div class="tip" id="fs21">val filteredTweets : AsyncSeq&lt;Tweet&gt;<br /><br />Full name: AsyncSeq.filteredTweets</div>
<div class="tip" id="fs22">val concatSeq : input:AsyncSeq&lt;#seq&lt;&#39;T&gt;&gt; -&gt; AsyncSeq&lt;&#39;T&gt;<br /><br />Full name: FSharpx.Control.AsyncSeq.concatSeq</div>
<div class="tip" id="fs23">val filterAsync : f:(&#39;T -&gt; Async&lt;bool&gt;) -&gt; input:AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;T&gt;<br /><br />Full name: FSharpx.Control.AsyncSeq.filterAsync</div>
<div class="tip" id="fs24">val storeTweet : t:Tweet -&gt; Async&lt;unit&gt;<br /><br />Full name: AsyncSeq.storeTweet</div>
<div class="tip" id="fs25">type unit = Unit<br /><br />Full name: Microsoft.FSharp.Core.unit</div>
<div class="tip" id="fs26">val storeFilteredTweets : Async&lt;unit&gt;<br /><br />Full name: AsyncSeq.storeFilteredTweets</div>
<div class="tip" id="fs27">val iterAsync : f:(&#39;T -&gt; Async&lt;unit&gt;) -&gt; input:AsyncSeq&lt;&#39;T&gt; -&gt; Async&lt;unit&gt;<br /><br />Full name: FSharpx.Control.AsyncSeq.iterAsync</div>
<div class="tip" id="fs28">static member Async.RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:System.Threading.CancellationToken -&gt; &#39;T</div>
<div class="tip" id="fs29">val withTime : seq&lt;int&gt;<br /><br />Full name: AsyncSeq.withTime</div>
<div class="tip" id="fs30">Multiple items<br />val seq : sequence:seq&lt;&#39;T&gt; -&gt; seq&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Core.Operators.seq<br /><br />--------------------<br />type seq&lt;&#39;T&gt; = System.Collections.Generic.IEnumerable&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Collections.seq&lt;_&gt;</div>
<div class="tip" id="fs31">namespace System</div>
<div class="tip" id="fs32">namespace System.Threading</div>
<div class="tip" id="fs33">Multiple items<br />type Thread =<br />&#160;&#160;inherit CriticalFinalizerObject<br />&#160;&#160;new : start:ThreadStart -&gt; Thread + 3 overloads<br />&#160;&#160;member Abort : unit -&gt; unit + 1 overload<br />&#160;&#160;member ApartmentState : ApartmentState with get, set<br />&#160;&#160;member CurrentCulture : CultureInfo with get, set<br />&#160;&#160;member CurrentUICulture : CultureInfo with get, set<br />&#160;&#160;member DisableComObjectEagerCleanup : unit -&gt; unit<br />&#160;&#160;member ExecutionContext : ExecutionContext<br />&#160;&#160;member GetApartmentState : unit -&gt; ApartmentState<br />&#160;&#160;member GetCompressedStack : unit -&gt; CompressedStack<br />&#160;&#160;member GetHashCode : unit -&gt; int<br />&#160;&#160;...<br /><br />Full name: System.Threading.Thread<br /><br />--------------------<br />System.Threading.Thread(start: System.Threading.ThreadStart) : unit<br />System.Threading.Thread(start: System.Threading.ParameterizedThreadStart) : unit<br />System.Threading.Thread(start: System.Threading.ThreadStart, maxStackSize: int) : unit<br />System.Threading.Thread(start: System.Threading.ParameterizedThreadStart, maxStackSize: int) : unit</div>
<div class="tip" id="fs34">System.Threading.Thread.Sleep(timeout: System.TimeSpan) : unit<br />System.Threading.Thread.Sleep(millisecondsTimeout: int) : unit</div>
<div class="tip" id="fs35">val withTime&#39; : AsyncSeq&lt;int&gt;<br /><br />Full name: AsyncSeq.withTime&#39;</div>
<div class="tip" id="fs36">static member Async.Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;</div>
<div class="tip" id="fs37">val tweetsObs : IObservable&lt;Tweet&gt;<br /><br />Full name: AsyncSeq.tweetsObs</div>
<div class="tip" id="fs38">type IObservable&lt;&#39;T&gt; =<br />&#160;&#160;member Subscribe : observer:IObserver&lt;&#39;T&gt; -&gt; IDisposable<br /><br />Full name: System.IObservable&lt;_&gt;</div>
<div class="tip" id="fs39">val filteredTweetsObs : IObservable&lt;Tweet&gt;<br /><br />Full name: AsyncSeq.filteredTweetsObs</div>
<div class="tip" id="fs40">Multiple items<br />module Observable<br /><br />from FSharpx.Control<br /><br />--------------------<br />module Observable<br /><br />from Microsoft.FSharp.Control</div>
<div class="tip" id="fs41">val filter : predicate:(&#39;T -&gt; bool) -&gt; source:IObservable&lt;&#39;T&gt; -&gt; IObservable&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Control.Observable.filter</div>
<div class="tip" id="fs42">static member Async.RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:Threading.CancellationToken -&gt; &#39;T</div>
<div class="tip" id="fs43">val ofAsync : a:Async&lt;&#39;a&gt; -&gt; IObservable&lt;&#39;a&gt;<br /><br />Full name: AsyncSeq.Observable.ofAsync<br /><em><br /><br />&#160;a |&gt; Async.StartAsTask |&gt; (fun t -&gt; t.ToObservable())</em></div>
<div class="tip" id="fs44">val a : Async&lt;&#39;a&gt;</div>
<div class="tip" id="fs45">val bind : f:(&#39;a -&gt; IObservable&lt;&#39;b&gt;) -&gt; o:IObservable&lt;&#39;a&gt; -&gt; IObservable&lt;&#39;b&gt;<br /><br />Full name: AsyncSeq.Observable.bind<br /><em><br /><br />&#160;Observable.SelectMany</em></div>
<div class="tip" id="fs46">val f : (&#39;a -&gt; IObservable&lt;&#39;b&gt;)</div>
<div class="tip" id="fs47">val o : IObservable&lt;&#39;a&gt;</div>
<div class="tip" id="fs48">val filterObs : f:(&#39;a -&gt; IObservable&lt;bool&gt;) -&gt; (IObservable&lt;&#39;a&gt; -&gt; IObservable&lt;&#39;a&gt;)<br /><br />Full name: AsyncSeq.Observable.filterObs</div>
<div class="tip" id="fs49">val f : (&#39;a -&gt; IObservable&lt;bool&gt;)</div>
<div class="tip" id="fs50">type bool = Boolean<br /><br />Full name: Microsoft.FSharp.Core.bool</div>
<div class="tip" id="fs51">val a : &#39;a</div>
<div class="tip" id="fs52">val choose : chooser:(&#39;T -&gt; &#39;U option) -&gt; source:IObservable&lt;&#39;T&gt; -&gt; IObservable&lt;&#39;U&gt;<br /><br />Full name: Microsoft.FSharp.Control.Observable.choose</div>
<div class="tip" id="fs53">union case Option.Some: Value: &#39;T -&gt; Option&lt;&#39;T&gt;</div>
<div class="tip" id="fs54">union case Option.None: Option&lt;&#39;T&gt;</div>
<div class="tip" id="fs55">val filterAsync : f:(&#39;a -&gt; Async&lt;bool&gt;) -&gt; (IObservable&lt;&#39;a&gt; -&gt; IObservable&lt;&#39;a&gt;)<br /><br />Full name: AsyncSeq.Observable.filterAsync</div>
<div class="tip" id="fs56">val f : (&#39;a -&gt; Async&lt;bool&gt;)</div>
<div class="tip" id="fs57">val mapAsync : f:(&#39;a -&gt; Async&lt;&#39;b&gt;) -&gt; (IObservable&lt;&#39;a&gt; -&gt; IObservable&lt;&#39;b&gt;)<br /><br />Full name: AsyncSeq.Observable.mapAsync</div>
<div class="tip" id="fs58">val f : (&#39;a -&gt; Async&lt;&#39;b&gt;)</div>
<div class="tip" id="fs59">val filteredTweetsObs&#39; : IObservable&lt;Tweet&gt;<br /><br />Full name: AsyncSeq.filteredTweetsObs&#39;</div>
<div class="tip" id="fs60">Multiple items<br />module Observable<br /><br />from AsyncSeq<br /><br />--------------------<br />module Observable<br /><br />from FSharpx.Control<br /><br />--------------------<br />module Observable<br /><br />from Microsoft.FSharp.Control</div>
<div class="tip" id="fs61">val storedTweetsObs : IObservable&lt;unit&gt;<br /><br />Full name: AsyncSeq.storedTweetsObs</div>
<div class="tip" id="fs62">val storedTeetsObs&#39; : IObservable&lt;unit&gt;<br /><br />Full name: AsyncSeq.storedTeetsObs&#39;</div>

        </div>
        <div class="span3">
          <img src="/FSharpx.Async/img/logo.png" alt="F# Project" style="width:150px;margin:10px" />  
          <ul class="nav nav-list" id="menu" style="margin-top: 20px;">
            <li class="nav-header">FSharpx.Async</li>
            <li><a href="/FSharpx.Async/index.html">Home page</a></li>
            <li class="divider"></li>
            <li><a href="http://nuget.org/packages/FSharpx.Async">Get Library via NuGet</a></li>
            <li><a href="http://github.com/fsprojects/FSharpx.Async">Source Code on GitHub</a></li>
            <li><a href="/FSharpx.Async/license.html">License</a></li>
            <li><a href="/FSharpx.Async/release-notes.html">Release Notes</a></li>
            <li class="divider"></li>
            <li class="nav-header">Documentation</li>
            <li><a href="/FSharpx.Async/terminology.html">Terminology</a></li>
            <li><a href="/FSharpx.Async/library/AsyncSeq.html">AsyncSeq</a></li>           
            <li><a href="/FSharpx.Async/reference/index.html">API Reference</a></li>
          </ul>
        </div>
      </div>
    </div>
    <a href="http://github.com/fsprojects/FSharpx.Async"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"/></a>
  </body>
  </html>
